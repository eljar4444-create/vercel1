generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(uuid())
  name            String?
  email           String?          @unique
  emailVerified   DateTime?
  image           String?
  password        String?
  role            String           @default("CLIENT")
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  bio             String?
  accounts        Account[]
  orders          Order[]
  providerProfile ProviderProfile?
  requests        Request[]        @relation("ClientRequests")
  reviews         Review[]         @relation("ClientReviews")
  sessions        Session[]
  chatMessages    ChatMessage[]
  
  // Link to new Directory Profile
  directoryProfile Profile?
}

// --- NEW SERVICE DIRECTORY MODELS ---

model Category {
  id          Int       @id @default(autoincrement())
  name        String
  slug        String    @unique
  icon        String?
  form_schema Json      // Dynamic questions for the category
  profiles    Profile[]
}

model Profile {
  id          Int       @id @default(autoincrement())
  user_email  String    @unique
  name        String
  city        String
  address     String?
  category_id Int
  attributes  Json      // Flexible data: { "home_visit": true, etc. }
  image_url   String?   // Vercel Blob link
  is_vip      Boolean   @default(false)
  created_at  DateTime  @default(now())

  category    Category  @relation(fields: [category_id], references: [id])
  services    DirectoryService[]
  user        User?     @relation(fields: [user_email], references: [email])
}

model DirectoryService {
  id         Int      @id @default(autoincrement())
  profile_id Int
  title      String
  price      Decimal  @db.Decimal(10, 2)
  duration   Int      // in minutes

  profile    Profile  @relation(fields: [profile_id], references: [id])
}

// --- KEEPING EXISTING MODELS FOR COMPATIBILITY ---
// (Renaming existing Service to avoid conflict)

model Account {
  id                String   @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model ProviderProfile {
  id                 String                 @id @default(uuid())
  userId             String                 @unique
  bio                String?
  rating             Float                  @default(0)
  reviewCount        Int                    @default(0)
  verificationStatus String                 @default("IDLE")
  verificationDocs   String?
  age                Int?
  contactTime        String?
  education          String?
  type               String                 @default("PRIVATE")
  address            String?
  city               String?
  latitude           Float?
  longitude          Float?
  serviceRadius      Int                    @default(10)
  user               User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptions      ProviderSubscription[]
  receivedRequests   Request[]              @relation("ProviderRequests")
  services           Service[]
}

model ServiceCategory {
  id       String    @id @default(uuid())
  name     String    @unique
  slug     String    @unique
  image    String?
  orders   Order[]
  services Service[]
}

model City {
  id       String    @id @default(uuid())
  name     String    @unique
  slug     String    @unique
  services Service[]
}

model Service {
  id                String          @id @default(uuid())
  title             String
  description       String
  price             Float?
  status            String          @default("PENDING")
  providerProfileId String
  categoryId        String
  cityId            String
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  latitude          Float?
  longitude         Float?
  subcategory       String?
  equipment         String?
  experience        Int?
  locationType      String?
  schedule          String?
  workTime          String?
  
  priceList        String? // JSON string

  requests          Request[]
  reviews           Review[]
  city              City            @relation(fields: [cityId], references: [id])
  category          ServiceCategory @relation(fields: [categoryId], references: [id])
  providerProfile   ProviderProfile @relation(fields: [providerProfileId], references: [id], onDelete: Cascade)
  photos            ServiceImage[]
}

model ServiceImage {
  id        String   @id @default(uuid())
  url       String
  serviceId String
  createdAt DateTime @default(now())
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model Request {
  id                String          @id @default(uuid())
  message           String
  status            String          @default("PENDING")
  clientId          String
  providerProfileId String
  serviceId         String
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  service           Service         @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  providerProfile   ProviderProfile @relation("ProviderRequests", fields: [providerProfileId], references: [id], onDelete: Cascade)
  client            User            @relation("ClientRequests", fields: [clientId], references: [id], onDelete: Cascade)
  messages          ChatMessage[]
}

model ChatMessage {
  id        String   @id @default(uuid())
  content   String
  senderId  String
  requestId String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  request   Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
}

model Review {
  id        String   @id @default(uuid())
  rating    Int
  comment   String?
  serviceId String
  authorId  String
  createdAt DateTime @default(now())
  author    User     @relation("ClientReviews", fields: [authorId], references: [id], onDelete: Cascade)
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model Order {
  id          String          @id @default(uuid())
  title       String
  description String
  budget      Float?
  address     String?
  subcategory String?
  status      String          @default("PENDING_MODERATION")
  clientId    String
  categoryId  String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  latitude    Float?
  longitude   Float?
  category    ServiceCategory @relation(fields: [categoryId], references: [id])
  client      User            @relation(fields: [clientId], references: [id], onDelete: Cascade)
}

model SubscriptionPlan {
  id            String                 @id @default(uuid())
  name          String                 @unique
  price         Float
  features      String
  subscriptions ProviderSubscription[]
}

model ProviderSubscription {
  id                String           @id @default(uuid())
  providerProfileId String
  planId            String
  startsAt          DateTime         @default(now())
  endsAt            DateTime?
  isActive          Boolean          @default(true)
  plan              SubscriptionPlan @relation(fields: [planId], references: [id])
  providerProfile   ProviderProfile  @relation(fields: [providerProfileId], references: [id], onDelete: Cascade)
}

